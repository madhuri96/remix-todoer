"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendRemixResponse = exports.createRemixHeaders = exports.createRemixRequest = exports.createRequestHandler = void 0;
const node_1 = require("@remix-run/node");
const binary_types_1 = require("./binary-types");
function createRequestHandler({ build, getLoadContext, mode = process.env.NODE_ENV, }) {
    const handleRequest = (0, node_1.createRequestHandler)(build, mode);
    return async (event, context) => {
        const request = createRemixRequest(event);
        const loadContext = await (getLoadContext === null || getLoadContext === void 0 ? void 0 : getLoadContext(event, context));
        const response = (await handleRequest(request, loadContext));
        return sendRemixResponse(response);
    };
}
exports.createRequestHandler = createRequestHandler;
function createRemixRequest(event) {
    var _a;
    let url;
    if (process.env.NODE_ENV !== 'development') {
        url = new URL(event.rawUrl);
    }
    else {
        const origin = event.headers.host;
        const rawPath = getRawPath(event);
        url = new URL(`http://${origin}${rawPath}`);
    }
    // Note: No current way to abort these for Netlify, but our router expects
    // requests to contain a signal so it can detect aborted requests
    const controller = new node_1.AbortController();
    const init = {
        method: event.httpMethod,
        headers: createRemixHeaders(event.multiValueHeaders),
        // Cast until reason/throwIfAborted added
        // https://github.com/mysticatea/abort-controller/issues/36
        signal: controller.signal,
    };
    if (event.httpMethod !== 'GET' && event.httpMethod !== 'HEAD' && event.body) {
        const isFormData = (_a = event.headers['content-type']) === null || _a === void 0 ? void 0 : _a.includes('multipart/form-data');
        init.body = event.isBase64Encoded
            ? isFormData
                ? Buffer.from(event.body, 'base64')
                : Buffer.from(event.body, 'base64').toString()
            : event.body;
    }
    return new node_1.Request(url.href, init);
}
exports.createRemixRequest = createRemixRequest;
function createRemixHeaders(requestHeaders) {
    const headers = new node_1.Headers();
    for (const [key, values] of Object.entries(requestHeaders)) {
        if (values) {
            for (const value of values) {
                headers.append(key, value);
            }
        }
    }
    return headers;
}
exports.createRemixHeaders = createRemixHeaders;
// `netlify dev` doesn't return the full url in the event.rawUrl, so we need to create it ourselves
function getRawPath(event) {
    let rawPath = event.path;
    const searchParams = new URLSearchParams();
    if (!event.multiValueQueryStringParameters) {
        return rawPath;
    }
    const paramKeys = Object.keys(event.multiValueQueryStringParameters);
    for (const key of paramKeys) {
        const values = event.multiValueQueryStringParameters[key];
        if (!values)
            continue;
        for (const val of values) {
            searchParams.append(key, val);
        }
    }
    const rawParams = searchParams.toString();
    if (rawParams)
        rawPath += `?${rawParams}`;
    return rawPath;
}
async function sendRemixResponse(nodeResponse) {
    const contentType = nodeResponse.headers.get('Content-Type');
    let body;
    const isBase64Encoded = (0, binary_types_1.isBinaryType)(contentType);
    if (nodeResponse.body) {
        if (isBase64Encoded) {
            body = await (0, node_1.readableStreamToString)(nodeResponse.body, 'base64');
        }
        else {
            body = await nodeResponse.text();
        }
    }
    const multiValueHeaders = nodeResponse.headers.raw();
    return {
        statusCode: nodeResponse.status,
        multiValueHeaders,
        body,
        isBase64Encoded,
    };
}
exports.sendRemixResponse = sendRemixResponse;
